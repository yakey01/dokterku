name: 🤖 Claude Auto-Fix Pipeline

on:
  workflow_run:
    workflows: ["🚀 Enhanced Deployment Pipeline"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      force_fix:
        description: 'Force Claude to analyze and fix issues'
        required: false
        default: false
        type: boolean
      target_branch:
        description: 'Branch to fix'
        required: false
        default: 'main'
        type: string

env:
  CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  # ============================================================================
  # ERROR DETECTION & ANALYSIS
  # ============================================================================
  detect-errors:
    name: 🕵️ Detect Errors
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' || github.event.inputs.force_fix == 'true' }}
    outputs:
      has_errors: ${{ steps.analyze.outputs.has_errors }}
      error_summary: ${{ steps.analyze.outputs.error_summary }}
      error_files: ${{ steps.analyze.outputs.error_files }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_branch || github.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: "8.3"
          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, sqlite, pdo_sqlite, bcmath, soap, intl, gd, exif, iconv
          tools: composer:v2

      - name: Install dependencies
        run: composer install --no-interaction --prefer-dist

      - name: Analyze errors and collect diagnostics
        id: analyze
        run: |
          echo "🔍 Starting comprehensive error analysis..."
          
          # Create error report
          ERROR_REPORT="error_analysis.json"
          
          # Initialize error report
          cat > $ERROR_REPORT << 'EOF'
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "repository": "${{ github.repository }}",
            "branch": "${{ github.ref_name }}",
            "commit": "${{ github.sha }}",
            "errors": [],
            "suggestions": []
          }
          EOF
          
          # Run tests and capture errors
          echo "🧪 Running tests to detect errors..."
          if ! php artisan test --json > test_results.json 2>&1; then
            echo "❌ Tests failed, analyzing errors..."
            
            # Parse test failures
            if [ -f test_results.json ]; then
              # Extract failed test information
              jq -r '.[] | select(.status == "failed") | .message' test_results.json > failed_tests.txt || echo "No JSON test output"
            fi
            
            # Run PHPStan for static analysis
            if [ -f vendor/bin/phpstan ]; then
              echo "🔬 Running PHPStan analysis..."
              vendor/bin/phpstan analyse --error-format=json > phpstan_errors.json 2>&1 || true
            fi
            
            # Run PHP CodeSniffer
            if [ -f vendor/bin/phpcs ]; then
              echo "📏 Running code style analysis..."
              vendor/bin/phpcs --report=json app/ > phpcs_errors.json 2>&1 || true
            fi
            
            # Collect syntax errors
            echo "🐛 Checking for PHP syntax errors..."
            find app tests -name "*.php" -exec php -l {} \; > syntax_check.log 2>&1
            
            HAS_ERRORS="true"
          else
            echo "✅ All tests passed"
            HAS_ERRORS="false"
          fi
          
          # Check for other issues
          echo "🔍 Checking for additional issues..."
          
          # Check for missing dependencies
          composer validate --no-check-publish 2>&1 | tee composer_issues.log
          
          # Check for security vulnerabilities
          if command -v composer &> /dev/null; then
            composer audit --format=json > security_audit.json 2>&1 || true
          fi
          
          # Analyze log files for runtime errors
          if [ -d storage/logs ]; then
            find storage/logs -name "*.log" -mtime -1 -exec grep -l "ERROR\|CRITICAL\|Exception" {} \; > recent_errors.log || true
          fi
          
          # Create comprehensive error summary
          ERROR_SUMMARY=""
          ERROR_FILES=""
          
          if [ "$HAS_ERRORS" = "true" ]; then
            ERROR_SUMMARY="Detected multiple issues: "
            
            # Collect failed tests
            if [ -f failed_tests.txt ] && [ -s failed_tests.txt ]; then
              TEST_COUNT=$(wc -l < failed_tests.txt)
              ERROR_SUMMARY+="$TEST_COUNT failing tests, "
              ERROR_FILES+="failed_tests.txt,"
            fi
            
            # Collect static analysis issues
            if [ -f phpstan_errors.json ]; then
              PHPSTAN_COUNT=$(jq '.totals.file_errors // 0' phpstan_errors.json 2>/dev/null || echo "0")
              if [ "$PHPSTAN_COUNT" -gt 0 ]; then
                ERROR_SUMMARY+="$PHPSTAN_COUNT static analysis issues, "
                ERROR_FILES+="phpstan_errors.json,"
              fi
            fi
            
            # Collect code style issues
            if [ -f phpcs_errors.json ]; then
              PHPCS_COUNT=$(jq '.totals.errors + .totals.warnings' phpcs_errors.json 2>/dev/null || echo "0")
              if [ "$PHPCS_COUNT" -gt 0 ]; then
                ERROR_SUMMARY+="$PHPCS_COUNT code style issues, "
                ERROR_FILES+="phpcs_errors.json,"
              fi
            fi
            
            # Check syntax errors
            if grep -q "Parse error\|Fatal error\|syntax error" syntax_check.log; then
              SYNTAX_COUNT=$(grep -c "Parse error\|Fatal error\|syntax error" syntax_check.log || echo "0")
              ERROR_SUMMARY+="$SYNTAX_COUNT syntax errors, "
              ERROR_FILES+="syntax_check.log,"
            fi
          fi
          
          # Remove trailing comma
          ERROR_SUMMARY=${ERROR_SUMMARY%, }
          ERROR_FILES=${ERROR_FILES%,}
          
          echo "has_errors=$HAS_ERRORS" >> $GITHUB_OUTPUT
          echo "error_summary=$ERROR_SUMMARY" >> $GITHUB_OUTPUT
          echo "error_files=$ERROR_FILES" >> $GITHUB_OUTPUT
          
          echo "📊 Analysis complete:"
          echo "- Has errors: $HAS_ERRORS"
          echo "- Summary: $ERROR_SUMMARY"
          echo "- Files: $ERROR_FILES"

      - name: Upload error artifacts
        if: steps.analyze.outputs.has_errors == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: error-analysis-${{ github.run_id }}
          path: |
            *.json
            *.log
            *.txt
          retention-days: 7

  # ============================================================================
  # CLAUDE-POWERED AUTO-FIX
  # ============================================================================
  claude-auto-fix:
    name: 🤖 Claude Auto-Fix
    runs-on: ubuntu-latest
    needs: detect-errors
    if: needs.detect-errors.outputs.has_errors == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Download error analysis
        uses: actions/download-artifact@v4
        with:
          name: error-analysis-${{ github.run_id }}
          path: ./errors/

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: "8.3"
          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, sqlite, pdo_sqlite, bcmath, soap, intl, gd, exif, iconv
          tools: composer:v2

      - name: Install dependencies
        run: composer install --no-interaction --prefer-dist

      - name: Claude Analysis and Fix
        id: claude-fix
        run: |
          echo "🤖 Starting Claude-powered auto-fix..."
          
          # Check if Claude API key is available
          if [ -z "${{ secrets.CLAUDE_API_KEY }}" ]; then
            echo "❌ CLAUDE_API_KEY not configured. Please add it to repository secrets."
            echo "🔗 Get your API key from: https://console.anthropic.com/"
            exit 1
          fi
          
          # Create Claude fix script
          cat > claude_fix.py << 'PYTHON_SCRIPT'
          import json
          import os
          import requests
          import sys
          from pathlib import Path
          
          class ClaudeAutoFix:
              def __init__(self, api_key):
                  self.api_key = api_key
                  self.base_url = "https://api.anthropic.com/v1/messages"
                  self.headers = {
                      "x-api-key": api_key,
                      "anthropic-version": "2023-06-01",
                      "content-type": "application/json"
                  }
              
              def analyze_and_fix(self, error_files, codebase_path):
                  """Analyze errors and generate fixes"""
                  print("🔍 Analyzing errors with Claude...")
                  
                  # Collect error information
                  errors_info = self.collect_errors(error_files)
                  codebase_context = self.get_codebase_context(codebase_path)
                  
                  # Prepare Claude prompt
                  prompt = self.create_fix_prompt(errors_info, codebase_context)
                  
                  # Get Claude's analysis and fixes
                  response = self.call_claude(prompt)
                  
                  if response:
                      return self.parse_and_apply_fixes(response)
                  
                  return False
              
              def collect_errors(self, error_files):
                  """Collect all error information from files"""
                  errors = {}
                  
                  for file_path in error_files:
                      if os.path.exists(file_path):
                          try:
                              with open(file_path, 'r') as f:
                                  if file_path.endswith('.json'):
                                      errors[file_path] = json.load(f)
                                  else:
                                      errors[file_path] = f.read()
                          except Exception as e:
                              print(f"⚠️ Error reading {file_path}: {e}")
                  
                  return errors
              
              def get_codebase_context(self, path):
                  """Get relevant codebase context for fixing"""
                  context = {
                      "structure": [],
                      "key_files": {}
                  }
                  
                  # Get project structure
                  for root, dirs, files in os.walk(path):
                      # Skip vendor, node_modules, storage
                      dirs[:] = [d for d in dirs if d not in ['vendor', 'node_modules', 'storage', '.git']]
                      
                      level = root.replace(path, '').count(os.sep)
                      if level < 3:  # Limit depth
                          indent = ' ' * 2 * level
                          context["structure"].append(f"{indent}{os.path.basename(root)}/")
                          sub_indent = ' ' * 2 * (level + 1)
                          for file in files[:10]:  # Limit files
                              if file.endswith(('.php', '.js', '.ts', '.json', '.yml', '.yaml')):
                                  context["structure"].append(f"{sub_indent}{file}")
                  
                  # Get key files content
                  key_files = [
                      'composer.json',
                      'phpunit.xml',
                      '.env.example',
                      'app/Services/PetugasStatsService.php'
                  ]
                  
                  for file_path in key_files:
                      full_path = os.path.join(path, file_path)
                      if os.path.exists(full_path):
                          try:
                              with open(full_path, 'r') as f:
                                  context["key_files"][file_path] = f.read()[:5000]  # Limit size
                          except Exception as e:
                              print(f"⚠️ Error reading key file {file_path}: {e}")
                  
                  return context
              
              def create_fix_prompt(self, errors_info, codebase_context):
                  """Create comprehensive prompt for Claude"""
                  prompt = f"""You are an expert PHP/Laravel developer helping to automatically fix issues in a healthcare management system (Dokterku). 

          **CRITICAL SAFETY RULES:**
          1. ONLY fix clear, obvious errors - DO NOT make major architectural changes
          2. PRESERVE all existing functionality and business logic
          3. Focus on syntax errors, test failures, and obvious bugs
          4. DO NOT modify database migrations or critical business logic
          5. Always provide explanations for each fix

          **PROJECT CONTEXT:**
          Repository: Medical clinic management system built with Laravel + Filament
          Technology Stack: PHP 8.3, Laravel 11, Filament, MySQL, React/TypeScript

          **PROJECT STRUCTURE:**
          {chr(10).join(codebase_context["structure"][:50])}

          **DETECTED ERRORS:**
          {json.dumps(errors_info, indent=2)}

          **KEY FILES CONTEXT:**
          {json.dumps(codebase_context["key_files"], indent=2)}

          **YOUR TASK:**
          Analyze the errors and provide SPECIFIC, TARGETED fixes. For each fix:

          1. **Identify the root cause**
          2. **Provide the exact fix** (file path + code changes)
          3. **Explain why this fix is safe and necessary**
          4. **Ensure compatibility** with existing code

          **OUTPUT FORMAT:**
          Return a JSON response with this structure:
          {{
            "analysis": "Brief analysis of the main issues",
            "fixes": [
              {{
                "file": "relative/path/to/file.php",
                "description": "What this fix does",
                "type": "fix|update|create",
                "changes": [
                  {{
                    "action": "replace|add|remove",
                    "line_number": 123,
                    "old_content": "content to replace",
                    "new_content": "replacement content",
                    "reason": "why this change is needed"
                  }}
                ]
              }}
            ],
            "safety_notes": "Important safety considerations",
            "test_recommendations": "Recommended tests to run after fixes"
          }}

          Focus on the most critical issues first. BE CONSERVATIVE - only fix what you're 100% confident about."""
                  
                  return prompt
              
              def call_claude(self, prompt):
                  """Call Claude API"""
                  try:
                      payload = {
                          "model": "claude-3-sonnet-20240229",
                          "max_tokens": 4000,
                          "messages": [
                              {
                                  "role": "user",
                                  "content": prompt
                              }
                          ]
                      }
                      
                      response = requests.post(
                          self.base_url,
                          headers=self.headers,
                          json=payload,
                          timeout=60
                      )
                      
                      if response.status_code == 200:
                          result = response.json()
                          return result["content"][0]["text"]
                      else:
                          print(f"❌ Claude API error: {response.status_code}")
                          print(f"Response: {response.text}")
                          return None
                          
                  except Exception as e:
                      print(f"❌ Error calling Claude: {e}")
                      return None
              
              def parse_and_apply_fixes(self, claude_response):
                  """Parse Claude response and apply fixes"""
                  try:
                      # Extract JSON from Claude's response
                      import re
                      json_match = re.search(r'\{.*\}', claude_response, re.DOTALL)
                      if not json_match:
                          print("❌ Could not extract JSON from Claude response")
                          return False
                      
                      fixes_data = json.loads(json_match.group())
                      
                      print(f"📋 Claude Analysis: {fixes_data.get('analysis', 'No analysis provided')}")
                      print(f"🔒 Safety Notes: {fixes_data.get('safety_notes', 'No safety notes')}")
                      
                      applied_fixes = 0
                      
                      for fix in fixes_data.get("fixes", []):
                          if self.apply_single_fix(fix):
                              applied_fixes += 1
                      
                      print(f"✅ Applied {applied_fixes} fixes")
                      
                      # Save Claude's recommendations
                      with open("claude_recommendations.json", "w") as f:
                          json.dump(fixes_data, f, indent=2)
                      
                      return applied_fixes > 0
                      
                  except Exception as e:
                      print(f"❌ Error parsing Claude response: {e}")
                      print(f"Response was: {claude_response}")
                      return False
              
              def apply_single_fix(self, fix):
                  """Apply a single fix to a file"""
                  try:
                      file_path = fix["file"]
                      print(f"🔧 Applying fix to {file_path}: {fix['description']}")
                      
                      if not os.path.exists(file_path):
                          if fix["type"] == "create":
                              # Create new file
                              os.makedirs(os.path.dirname(file_path), exist_ok=True)
                              with open(file_path, "w") as f:
                                  f.write("")
                          else:
                              print(f"❌ File {file_path} does not exist")
                              return False
                      
                      # Read current file content
                      with open(file_path, "r") as f:
                          lines = f.readlines()
                      
                      # Apply changes
                      for change in fix["changes"]:
                          if change["action"] == "replace":
                              # Find and replace content
                              old_content = change["old_content"]
                              new_content = change["new_content"]
                              
                              file_content = "".join(lines)
                              if old_content in file_content:
                                  file_content = file_content.replace(old_content, new_content)
                                  lines = file_content.splitlines(True)
                                  print(f"  ✅ Replaced content: {change['reason']}")
                              else:
                                  print(f"  ⚠️ Could not find content to replace in {file_path}")
                      
                      # Write back to file
                      with open(file_path, "w") as f:
                          f.writelines(lines)
                      
                      return True
                      
                  except Exception as e:
                      print(f"❌ Error applying fix to {fix['file']}: {e}")
                      return False
          
          # Main execution
          if __name__ == "__main__":
              api_key = os.environ.get("CLAUDE_API_KEY")
              if not api_key:
                  print("❌ CLAUDE_API_KEY environment variable not set")
                  sys.exit(1)
              
              error_files = os.environ.get("ERROR_FILES", "").split(",")
              error_files = [f"./errors/{f.strip()}" for f in error_files if f.strip()]
              
              claude = ClaudeAutoFix(api_key)
              success = claude.analyze_and_fix(error_files, ".")
              
              if success:
                  print("✅ Claude auto-fix completed successfully")
                  sys.exit(0)
              else:
                  print("❌ Claude auto-fix failed")
                  sys.exit(1)
          PYTHON_SCRIPT
          
          # Install Python dependencies
          pip install requests
          
          # Run Claude auto-fix
          export CLAUDE_API_KEY="${{ secrets.CLAUDE_API_KEY }}"
          export ERROR_FILES="${{ needs.detect-errors.outputs.error_files }}"
          
          python claude_fix.py
          
          # Check if any files were modified
          if git diff --quiet; then
            echo "no_changes=true" >> $GITHUB_OUTPUT
            echo "🤷 No changes were made by Claude"
          else
            echo "no_changes=false" >> $GITHUB_OUTPUT
            echo "✅ Claude made changes to fix issues"
            
            # Show what changed
            echo "📝 Changes made by Claude:"
            git diff --name-only
          fi

      - name: Run tests after fixes
        if: steps.claude-fix.outputs.no_changes == 'false'
        run: |
          echo "🧪 Running tests after Claude fixes..."
          if php artisan test; then
            echo "✅ Tests are now passing after Claude fixes!"
            echo "test_success=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Tests still failing after Claude fixes"
            echo "test_success=false" >> $GITHUB_OUTPUT
          fi
        continue-on-error: true

      - name: Create Pull Request with fixes
        if: steps.claude-fix.outputs.no_changes == 'false'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            🤖 Auto-fix by Claude
            
            Claude has automatically analyzed and fixed detected issues:
            ${{ needs.detect-errors.outputs.error_summary }}
            
            🔧 Changes applied:
            - Analyzed error patterns and root causes
            - Applied targeted fixes with safety considerations
            - Preserved existing functionality and business logic
            
            🧪 Test Status: ${{ steps.claude-fix.outputs.test_success == 'true' && '✅ Tests now passing' || '❌ Tests still need attention' }}
            
            🤖 Generated with Claude Auto-Fix
            
            Co-authored-by: Claude <claude@anthropic.com>
          branch: claude-auto-fix-${{ github.run_id }}
          title: "🤖 Claude Auto-Fix: ${{ needs.detect-errors.outputs.error_summary }}"
          body: |
            ## 🤖 Claude Auto-Fix Report
            
            Claude has automatically analyzed and attempted to fix the following issues:
            
            ### 📊 Issues Detected
            ${{ needs.detect-errors.outputs.error_summary }}
            
            ### 🔧 Fixes Applied
            Claude applied targeted fixes based on error analysis. All changes were made with the following safety principles:
            
            - ✅ Only fixed clear, obvious errors
            - ✅ Preserved all existing functionality
            - ✅ Focused on syntax errors and test failures
            - ✅ Did not modify critical business logic
            
            ### 🧪 Test Results
            - **Before fixes**: ❌ Tests failing
            - **After fixes**: ${{ steps.claude-fix.outputs.test_success == 'true' && '✅ Tests passing' || '❌ Tests still need attention' }}
            
            ### 📋 Recommendations
            Please review the changes carefully before merging:
            
            1. **Verify** that the fixes address the root causes
            2. **Test** thoroughly in a development environment
            3. **Check** that no functionality was broken
            4. **Consider** any additional improvements needed
            
            ### 🔍 Files Changed
            Check the "Files changed" tab to see exactly what Claude modified.
            
            ---
            
            🤖 This PR was automatically created by Claude Auto-Fix
            ⚡ Powered by Claude API and GitHub Actions
            
            **Safe to merge?** ${{ steps.claude-fix.outputs.test_success == 'true' && '✅ Likely safe - tests are passing' || '⚠️ Review carefully - tests may still be failing' }}
          labels: |
            🤖 auto-fix
            🔧 bug-fix
            🧪 needs-testing
          reviewers: |
            ${{ github.actor }}

      - name: Send notification
        if: always()
        run: |
          echo "📢 Claude Auto-Fix Summary:"
          echo "=========================="
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Errors detected: ${{ needs.detect-errors.outputs.has_errors }}"
          echo "Fixes applied: ${{ steps.claude-fix.outputs.no_changes == 'false' && 'Yes' || 'No' }}"
          echo "Tests passing: ${{ steps.claude-fix.outputs.test_success }}"
          echo ""
          echo "🤖 Claude Auto-Fix completed!"

  # ============================================================================
  # SAFETY MONITORING
  # ============================================================================
  safety-monitor:
    name: 🛡️ Safety Monitor
    runs-on: ubuntu-latest
    needs: [detect-errors, claude-auto-fix]
    if: always()
    
    steps:
      - name: Monitor Claude changes
        run: |
          echo "🛡️ Monitoring Claude Auto-Fix safety..."
          
          # Log Claude activity
          echo "📊 Auto-Fix Statistics:"
          echo "- Errors detected: ${{ needs.detect-errors.outputs.has_errors }}"
          echo "- Changes made: ${{ needs.claude-auto-fix.outputs.no_changes == 'false' && 'Yes' || 'No' }}"
          echo "- Repository: ${{ github.repository }}"
          echo "- Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          # Safety recommendations
          echo ""
          echo "🔒 Safety Recommendations:"
          echo "1. Always review Claude's changes before merging"
          echo "2. Test thoroughly in development environment"
          echo "3. Monitor for any unexpected behavior"
          echo "4. Keep Claude API key secure and rotate regularly"
          
          echo "✅ Safety monitoring complete"