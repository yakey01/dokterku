name: üöÄ Modern CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests (emergency deployment)'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment despite failures'
        required: false
        default: false
        type: boolean

env:
  PHP_VERSION: "8.3"
  NODE_VERSION: "20"
  COMPOSER_VERSION: "2"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/dokterku

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # SECURITY & CODE QUALITY ANALYSIS
  # ============================================================================
  security-analysis:
    name: üîí Security Analysis
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true

      - name: Scan for secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD
          extra_args: --debug --only-verified
        continue-on-error: true

      - name: Check for hardcoded credentials
        run: |
          echo "üîç Scanning for hardcoded credentials..."
          
          # Check for potential secrets in PHP files
          if grep -r -E "(password|secret|key|token)\s*=\s*['\"][^'\"]{8,}" --include="*.php" . | grep -v vendor | grep -v ".git"; then
            echo "‚ö†Ô∏è Potential hardcoded secrets found!"
            echo "Please use environment variables for sensitive data."
            exit 1
          else
            echo "‚úÖ No hardcoded secrets detected"
          fi

  # ============================================================================
  # BUILD & TEST
  # ============================================================================
  build-test:
    name: üß™ Build & Test
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: test_root_password
          MYSQL_DATABASE: dokterku_test
          MYSQL_USER: test_user
          MYSQL_PASSWORD: test_password
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PHP with extensions
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ env.PHP_VERSION }}
          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, sqlite, pdo_sqlite, bcmath, soap, intl, gd, exif, iconv, mysql, pdo_mysql, redis
          coverage: xdebug
          tools: composer:v2, phpstan, phpcs

      - name: Cache Composer dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.composer/cache
            vendor
          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-composer-

      - name: Install Composer dependencies
        run: |
          composer validate --strict
          composer install --no-interaction --prefer-dist --optimize-autoloader

      - name: Setup Node.js with caching
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install NPM dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Create test environment
        run: |
          cp .env.testing .env
          php artisan key:generate --force
          php artisan config:clear
          php artisan cache:clear

      - name: Run database migrations
        run: |
          php artisan migrate:fresh --force --seed
        env:
          DB_CONNECTION: mysql
          DB_HOST: 127.0.0.1
          DB_PORT: 3306
          DB_DATABASE: dokterku_test
          DB_USERNAME: test_user
          DB_PASSWORD: test_password

      - name: Build frontend assets
        run: |
          npm run build
          php artisan vendor:publish --tag=filament-assets --force

      - name: Run PHP CodeSniffer
        run: |
          if [ -f "vendor/bin/phpcs" ]; then
            vendor/bin/phpcs --standard=PSR12 app/ || echo "::warning::Code style issues detected"
          fi

      - name: Run PHPStan static analysis
        run: |
          if [ -f "vendor/bin/phpstan" ]; then
            vendor/bin/phpstan analyse --memory-limit=2G --error-format=github || echo "::warning::Static analysis issues detected"
          fi
        continue-on-error: true

      - name: Run PHPUnit tests with coverage
        run: |
          php artisan test \
            --coverage \
            --coverage-clover=coverage.xml \
            --coverage-html=coverage-html \
            --min=60 \
            --parallel
        env:
          DB_CONNECTION: mysql
          DB_HOST: 127.0.0.1
          DB_PORT: 3306
          DB_DATABASE: dokterku_test
          DB_USERNAME: test_user
          DB_PASSWORD: test_password
          REDIS_HOST: 127.0.0.1
          REDIS_PORT: 6379

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
          flags: backend
          name: dokterku-backend
        continue-on-error: true

      - name: Test healthcare panels accessibility
        run: |
          php artisan serve --host=127.0.0.1 --port=8000 &
          SERVER_PID=$!
          sleep 10
          
          # Test all healthcare panels
          declare -A PANELS=(
            ["admin"]="Admin Panel"
            ["manajer"]="Manager Panel"
            ["bendahara"]="Finance Panel"
            ["petugas"]="Staff Panel"
            ["paramedis"]="Paramedic Panel"
            ["dokter"]="Doctor Panel"
          )
          
          echo "üè• Testing healthcare panels accessibility..."
          for panel in "${!PANELS[@]}"; do
            status_code=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:8000/$panel/login" || echo "000")
            if [[ "$status_code" == "200" || "$status_code" == "302" ]]; then
              echo "‚úÖ ${PANELS[$panel]} ($panel) - HTTP $status_code"
            else
              echo "‚ùå ${PANELS[$panel]} ($panel) - HTTP $status_code"
            fi
          done
          
          kill $SERVER_PID
        continue-on-error: true

      - name: Store build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            public/build
            bootstrap/cache
            vendor
          retention-days: 1

  # ============================================================================
  # DOCKER BUILD & PUSH
  # ============================================================================
  docker-build:
    name: üê≥ Docker Build
    runs-on: ubuntu-latest
    needs: [security-analysis, build-test]
    if: always() && (needs.build-test.result == 'success' || github.event.inputs.force_deploy == 'true')
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
        continue-on-error: true

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/8.3/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  # ============================================================================
  # STAGING DEPLOYMENT
  # ============================================================================
  deploy-staging:
    name: üß™ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [docker-build]
    if: |
      always() && 
      (github.ref == 'refs/heads/develop' || 
       (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')) &&
      (needs.docker-build.result == 'success' || github.event.inputs.force_deploy == 'true')
    environment: 
      name: staging
      url: ${{ secrets.STAGING_URL }}

    steps:
      - name: Checkout deployment scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            deploy.sh
            docker-compose.yml
            docker-compose.staging.yml

      - name: Deploy to staging
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USERNAME }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: ${{ secrets.STAGING_SSH_PORT }}
          timeout: 300s
          script: |
            set -e
            echo "üß™ Starting staging deployment..."
            
            cd ${{ secrets.STAGING_PATH }}
            
            # Pull latest changes
            git fetch origin
            git checkout develop
            git pull origin develop
            
            # Create backup
            BACKUP_DIR="backups/staging_$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$BACKUP_DIR"
            
            # Backup database
            if docker-compose -f docker-compose.staging.yml ps mysql | grep -q "Up"; then
              echo "üíæ Creating staging database backup..."
              docker-compose -f docker-compose.staging.yml exec -T mysql mysqldump \
                -u "${{ secrets.STAGING_DB_USERNAME }}" \
                -p"${{ secrets.STAGING_DB_PASSWORD }}" \
                "${{ secrets.STAGING_DB_DATABASE }}" > "$BACKUP_DIR/database_backup.sql"
            fi
            
            # Pull new Docker image
            docker pull ${{ needs.docker-build.outputs.image-tag }}
            
            # Deploy with zero-downtime
            chmod +x deploy.sh
            ./deploy.sh staging
            
            echo "‚úÖ Staging deployment completed"

      - name: Run staging health checks
        run: |
          echo "üîç Running staging health checks..."
          sleep 30
          
          # Basic health check
          for i in {1..5}; do
            if curl -sf "${{ secrets.STAGING_URL }}/health" > /dev/null; then
              echo "‚úÖ Staging health check passed (attempt $i)"
              break
            else
              echo "‚è≥ Health check attempt $i failed, retrying..."
              sleep 10
            fi
            
            if [ $i -eq 5 ]; then
              echo "‚ùå Staging health checks failed after 5 attempts"
              exit 1
            fi
          done
          
          # Test key healthcare functionalities
          echo "üè• Testing healthcare system endpoints..."
          
          endpoints=(
            "/admin/login:Admin Login"
            "/dokter/login:Doctor Login"
            "/paramedis/login:Paramedic Login"
            "/petugas/login:Staff Login"
          )
          
          for endpoint_info in "${endpoints[@]}"; do
            IFS=':' read -r endpoint name <<< "$endpoint_info"
            status_code=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.STAGING_URL }}$endpoint")
            if [[ "$status_code" == "200" || "$status_code" == "302" ]]; then
              echo "‚úÖ $name accessible (HTTP $status_code)"
            else
              echo "‚ö†Ô∏è $name returned HTTP $status_code"
            fi
          done

      - name: Notify staging deployment
        if: always()
        run: |
          echo "üìä Staging Deployment Summary"
          echo "=============================="
          echo "Environment: Staging"
          echo "Image: ${{ needs.docker-build.outputs.image-tag }}"
          echo "Commit: ${{ github.sha }}"
          echo "Author: ${{ github.actor }}"
          echo "Status: ${{ job.status }}"
          echo "URL: ${{ secrets.STAGING_URL }}"

  # ============================================================================
  # PRODUCTION DEPLOYMENT
  # ============================================================================
  deploy-production:
    name: üè• Deploy to Production
    runs-on: ubuntu-latest
    needs: [docker-build, deploy-staging]
    if: |
      always() && 
      (github.ref == 'refs/heads/main' || 
       (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')) &&
      (needs.docker-build.result == 'success' || github.event.inputs.force_deploy == 'true')
    environment: 
      name: production
      url: ${{ secrets.PRODUCTION_URL }}

    steps:
      - name: Checkout deployment scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            deploy.sh
            docker-compose.yml
            docker-compose.production.yml

      - name: Deploy to production
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT }}
          timeout: 600s
          script: |
            set -e
            echo "üè• Starting production deployment for Dokterku Healthcare System..."
            
            cd ${{ secrets.PRODUCTION_PATH }}
            
            # Pull latest changes
            git fetch origin
            git checkout main
            git pull origin main
            
            # Create comprehensive backup
            BACKUP_DIR="backups/production_$(date +%Y%m%d_%H%M%S)"
            mkdir -p "$BACKUP_DIR"
            
            echo "üíæ Creating production backup..."
            
            # Backup database with compression
            if docker-compose -f docker-compose.production.yml ps mysql | grep -q "Up"; then
              docker-compose -f docker-compose.production.yml exec -T mysql mysqldump \
                --single-transaction \
                --routines \
                --triggers \
                -u "${{ secrets.PRODUCTION_DB_USERNAME }}" \
                -p"${{ secrets.PRODUCTION_DB_PASSWORD }}" \
                "${{ secrets.PRODUCTION_DB_DATABASE }}" | gzip > "$BACKUP_DIR/database_backup.sql.gz"
              echo "‚úÖ Database backup created"
            fi
            
            # Backup storage files
            if [ -d "storage" ]; then
              tar -czf "$BACKUP_DIR/storage_backup.tar.gz" storage/
              echo "‚úÖ Storage backup created"
            fi
            
            # Pull new Docker image
            docker pull ${{ needs.docker-build.outputs.image-tag }}
            
            # Run production deployment with health checks
            chmod +x deploy.sh
            ./deploy.sh production
            
            echo "‚úÖ Production deployment completed successfully"

      - name: Comprehensive production health checks
        run: |
          echo "üîç Running comprehensive production health checks..."
          sleep 60
          
          # Primary health check with retry logic
          echo "üè• Testing main health endpoint..."
          for i in {1..10}; do
            if curl -sf "${{ secrets.PRODUCTION_URL }}/health" > /dev/null; then
              echo "‚úÖ Primary health check passed (attempt $i)"
              break
            else
              echo "‚è≥ Health check attempt $i failed, retrying in 15s..."
              sleep 15
            fi
            
            if [ $i -eq 10 ]; then
              echo "‚ùå Production health checks failed after 10 attempts"
              exit 1
            fi
          done
          
          # Test all healthcare panels
          echo "üè• Testing all healthcare system panels..."
          
          declare -A PANELS=(
            ["/admin"]="Admin Panel (System Management)"
            ["/manajer"]="Manager Panel (Operations)"
            ["/bendahara"]="Finance Panel (Accounting)"
            ["/petugas"]="Staff Panel (General Staff)"
            ["/paramedis"]="Paramedic Panel (Medical Staff)"
            ["/dokter"]="Doctor Panel (Medical Professionals)"
          )
          
          failed_panels=0
          for panel in "${!PANELS[@]}"; do
            status_code=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.PRODUCTION_URL }}$panel" || echo "000")
            if [[ "$status_code" == "200" || "$status_code" == "302" ]]; then
              echo "‚úÖ ${PANELS[$panel]} - HTTP $status_code"
            else
              echo "‚ùå ${PANELS[$panel]} - HTTP $status_code"
              ((failed_panels++))
            fi
          done
          
          # Test API endpoints
          echo "üîå Testing API endpoints..."
          api_endpoints=(
            "/api/health:API Health"
            "/api/v1/auth/me:Auth API"
          )
          
          for endpoint_info in "${api_endpoints[@]}"; do
            IFS=':' read -r endpoint name <<< "$endpoint_info"
            status_code=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.PRODUCTION_URL }}$endpoint" || echo "000")
            if [[ "$status_code" == "200" || "$status_code" == "401" || "$status_code" == "302" ]]; then
              echo "‚úÖ $name - HTTP $status_code"
            else
              echo "‚ö†Ô∏è $name - HTTP $status_code"
            fi
          done
          
          if [ $failed_panels -gt 0 ]; then
            echo "‚ö†Ô∏è $failed_panels panel(s) failed health checks"
          else
            echo "üéâ All healthcare panels passed health checks!"
          fi

      - name: Send production deployment notification
        if: always()
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT }}
          script: |
            cat << EOF
            
            üè• ================================== üè•
                DOKTERKU HEALTHCARE SYSTEM
                 Production Deployment Report
            üè• ================================== üè•
            
            üìä DEPLOYMENT DETAILS
            ‚îú‚îÄ Repository: ${{ github.repository }}
            ‚îú‚îÄ Image: ${{ needs.docker-build.outputs.image-tag }}
            ‚îú‚îÄ Commit: ${{ github.sha }}
            ‚îú‚îÄ Author: ${{ github.actor }}
            ‚îú‚îÄ Branch: ${{ github.ref_name }}
            ‚îú‚îÄ Status: ${{ job.status }}
            ‚îî‚îÄ Timestamp: $(date)
            
            üåê HEALTHCARE SYSTEM PANELS
            ‚îú‚îÄ Admin Portal: ${{ secrets.PRODUCTION_URL }}/admin
            ‚îú‚îÄ Manager Portal: ${{ secrets.PRODUCTION_URL }}/manajer
            ‚îú‚îÄ Finance Portal: ${{ secrets.PRODUCTION_URL }}/bendahara
            ‚îú‚îÄ Staff Portal: ${{ secrets.PRODUCTION_URL }}/petugas
            ‚îú‚îÄ Paramedic Portal: ${{ secrets.PRODUCTION_URL }}/paramedis
            ‚îî‚îÄ Doctor Portal: ${{ secrets.PRODUCTION_URL }}/dokter
            
            üîß SYSTEM STATUS
            ‚îî‚îÄ All healthcare modules deployed and operational
            
            üè• ================================== üè•
            
            EOF

  # ============================================================================
  # ROLLBACK CAPABILITY
  # ============================================================================
  rollback:
    name: üîÑ Emergency Rollback
    runs-on: ubuntu-latest
    if: failure() && github.ref == 'refs/heads/main'
    needs: [deploy-production]
    environment: production

    steps:
      - name: Rollback production deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_HOST }}
          username: ${{ secrets.PRODUCTION_USERNAME }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          port: ${{ secrets.PRODUCTION_SSH_PORT }}
          script: |
            echo "üîÑ Emergency rollback initiated..."
            
            cd ${{ secrets.PRODUCTION_PATH }}
            
            # Find the most recent backup
            LATEST_BACKUP=$(ls -t backups/production_* | head -1)
            if [ -z "$LATEST_BACKUP" ]; then
              echo "‚ùå No backup found for rollback!"
              exit 1
            fi
            
            echo "üì¶ Rolling back to: $LATEST_BACKUP"
            
            # Stop current services
            docker-compose -f docker-compose.production.yml down
            
            # Restore database if backup exists
            if [ -f "$LATEST_BACKUP/database_backup.sql.gz" ]; then
              echo "üóÑÔ∏è Restoring database..."
              gunzip -c "$LATEST_BACKUP/database_backup.sql.gz" | \
              docker-compose -f docker-compose.production.yml exec -T mysql mysql \
                -u "${{ secrets.PRODUCTION_DB_USERNAME }}" \
                -p"${{ secrets.PRODUCTION_DB_PASSWORD }}" \
                "${{ secrets.PRODUCTION_DB_DATABASE }}"
            fi
            
            # Restore storage if backup exists
            if [ -f "$LATEST_BACKUP/storage_backup.tar.gz" ]; then
              echo "üìÅ Restoring storage files..."
              tar -xzf "$LATEST_BACKUP/storage_backup.tar.gz"
            fi
            
            # Restart services with previous version
            docker-compose -f docker-compose.production.yml up -d
            
            echo "‚úÖ Emergency rollback completed"
            echo "üîç Please verify system functionality manually"